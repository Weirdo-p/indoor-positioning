#include "../include/grid.h"
#include <vector>
#include <iostream>
#include <algorithm>
#include <fstream>
using namespace std;

const int ROW = 8;
const int COL = 29;

DataGrid::DataGrid(const GridPoint* grid) {
    // set abandon threshold
    this->threshold = 0.8;

    // fill data in the map
    for(int i = 0; i < ROW * COL; ++i){
        fillin(i, grid[i], this->grid);
    }
    // abandon mac which may be generated by personal hotspot
    for(Grid::iterator i = this->grid.begin(); i != this->grid.end(); ){
        int count = 0;
        for(int k = 0; k < this->grid[i->first].rows(); ++k)
            for(int j = 0; j < this->grid[i->first].cols(); ++j)
                if(this->grid[i->first](k, j) == 0){
                    // BiliInter(Point(k, j), i->first, this->grid);
                    count ++;
                }
        
        if(count > threshold * ROW * COL){
            this->grid.erase(i++);
        }
        else
            i ++;
        if(i == this->grid.end())
            break;
    }
    DataMap test = DataMap::Zero();
    for(Grid::iterator i = this->grid.begin(); i != this->grid.end(); ++i){
        if(i->first == "1a:69:6c:ea:a6:39"){
            ofstream out("/home/weirdo/Documents/coding/indoor-positioning/test.txt");
            for(int k = 0; k < ROW; ++k) {
                for(int j = 0; j < COL; ++j) {
                    out << this->grid[i->first](k, j);
                    if(j != COL - 1)
                        out << ",";
                }
                out << endl;
            }
        // test += this->grid[i->first];
        }

        cout << i->first << endl;
        cout << this->grid[i->first] << endl << endl;
    }
    // ofstream out("/home/weirdo/Documents/coding/indoor-positioning/test.txt");
    // for(int i = 0; i < ROW; ++i){
    //     for(int j = 0; j < COL; ++j){
    //         out << test(i, j);
    //         if(j != COL - 1)
    //             out << ",";
    //     }
    //     out << endl;
    // }

}

int DataGrid::fillin(int posi, GridPoint gp, Grid &gd) {
    Point p = GetPosition(posi);
    if(gp.size() == 0)
        return 1;
    for(GridPoint::iterator iter = gp.begin(); iter != gp.end(); ++iter){
        if(gd.find(iter->first) == gd.end())
            gd[iter->first] = DataMap::Zero();
        gd[iter->first](p.X, p.Y) = iter->second;
    }
    return 0;
}

Point DataGrid::GetPosition(int posi) {
    if(posi < COL)
        return Point(0, posi);
    int row = posi / COL;
    int col = posi % COL;
    return Point(row, col);
}

int DataGrid::BiliInter(Point pt, string mac, Grid &gd) {
    Point left(pt.X, pt.Y - 1);
    Point right(pt.X, pt.Y + 1);
    Point up(pt.X + 1, pt.Y);
    Point down(pt.X - 1, pt.Y);
    double l, r, u, d;
    double weight = 0.25;
    int count = 0;
    if(left.Y < 0)
        l = 0;
    else
        l = gd[mac](left.X, left.Y);
    if(l == 0)
        count ++;
    
    if(right.Y >= COL)
        r = 0;
    else
        r = gd[mac](right.X, right.Y);
    if(r == 0)
        count ++;

    if(up.X >= ROW)
        u = 0;
    else
        u = gd[mac](up.X, up.Y);
    if(u == 0)
        count ++;

    if(down.X < 0)
        d = 0;
    else
        d = gd[mac](down.X, down.Y);
    if(d == 0)
        count ++;
    
    // if(count == 0)
    //     weight = 0.25;
    if (count == 4)
        weight = 0;
    // if
    //     weight = 1.0 / (4 - count);
    
    double temp = weight * (u + d + l + r);
    gd[mac](pt.X, pt.Y) = temp;

    return 0;
}

double DataGrid::CalculateCoeff(Point pt, Grid gd, GridPoint gp) {
    double mean_obs = 0, mean_ref = 0, dist = 0;
    int count = 0;
    for(GridPoint::iterator iter = gp.begin(); iter != gp.end(); ++iter) {
        if(gd.find(iter->first) == gd.end()) {
            continue;
        }
        mean_obs += gp[iter->first];
        mean_ref += gd[iter->first](pt.X, pt.Y);
        count ++;
    }
    // if(count == gd.size())
    //     return 0;
    mean_ref /= (count);
    mean_obs /= (count);
    if(count == 0)
        return 0;

    double up = 0, down1 = 0, down2 = 0;;
    for(GridPoint::iterator iter = gp.begin(); iter != gp.end(); ++iter) {
        if(gd.find(iter->first) == gd.end()) {
            continue;
        }
        up += (gp[iter->first] - mean_obs) * (gd[iter->first](pt.X, pt.Y) - mean_ref);
        down1 += pow(gp[iter->first] - mean_obs, 2);
        down2 += pow(gd[iter->first](pt.X, pt.Y) - mean_ref, 2);
        // cout << iter->first << endl;
        // cout << gd[iter->first](pt.X, pt.Y) << endl;
    }
    // cout << down2 << endl;
    // cout << mean_ref << endl;
    // cout << endl;
    // double test = sqrt(down2) * sqrt(down1);
    // cout << test << endl;
    return up / sqrt(down2 * down1);

    // return (dist);
}

double DataGrid::CalculateDist(Point pt, Grid gd, GridPoint gp) {
    double dist = 0;
    for(GridPoint::iterator iter = gp.begin(); iter != gp.end(); ++iter) {
        if(gd.find(iter->first) == gd.end()) {
            continue;
        }
        dist += pow(gd[iter->first](pt.X, pt.Y) - gp[iter->first], 2);
    }
    return sqrt(dist);
}


Point DataGrid::positioning(GridPoint gp) {
    const int K = 1;
    stringstream tmp;
    tmp << K;
    string k = tmp.str();
    ofstream out_coef("./result/result_coef" + k + ".txt", ios::app);
    ofstream out_dist("./result/result_dist" + k + ".txt", ios::app);
    vector<double> result_coef, result_dist;
    for(int i = 0; i < ROW; ++i) {
        for(int j = 0; j < COL; ++j) {
            double val = CalculateCoeff(Point(i, j), this->grid, gp);
            double val_dist = CalculateDist(Point(i, j), this->grid, gp);
            if(val == -1) {
                continue;
                // cout << "!!!!!!!!!!" << endl;
            }
            result_coef.push_back(abs(val));
            result_dist.push_back(val_dist);
        }
    }
    Point result_point_coef(0, 0), result_point_dist(0, 0);

    vector<double> result_sort_coef = result_coef;
    vector<double> result_sort_dist = result_dist;
    sort(result_sort_coef.begin(), result_sort_coef.end());
    sort(result_sort_dist.begin(), result_sort_dist.end());

    int count_coef = 0, count_dist = 0;
    for(int i = result_sort_coef.size() - 1; i > 0; --i) {
        double coef = result_sort_coef[i];
        double dist = result_sort_dist[result_sort_dist.size() - i - 1];
        cout << i << "  " << coef << "   " << dist << endl;

        for(int j = 0; j < result_sort_coef.size(); ++j) {
            if(result_coef[j] == coef && count_coef != K){
                count_coef ++;
                Point pt = GetPosition(j);
                result_point_coef.X += pt.X;
                result_point_coef.Y += pt.Y;
            }
            if(result_dist[j] == dist && count_dist != K) {
                count_dist ++;
                Point pt = GetPosition(j);
                result_point_dist.X += pt.X;
                result_point_dist.Y += pt.Y;
                cout << dist << endl;
            }
        }

        if(count_coef == K && count_dist == K)  
            break;
    }
    result_point_coef.X /= count_coef;
    result_point_coef.Y /= count_coef;

    result_point_dist.X /= count_dist;
    result_point_dist.Y /= count_dist;
    // cout << result_point_coef  << endl;
    out_coef << result_point_coef.Y << " " << result_point_coef.X << endl;
    out_dist << result_point_dist.Y << " " << result_point_dist.X << endl;
}
